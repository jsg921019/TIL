<Problem41>

We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.
What is the largest n-digit pandigital prime that exists?

Answer:

from itertools import permutations

def isprime(p):
    if p%2==0 : return False
    for i in range(3,int(p**0.5)+1,2):
        if p%i == 0 : return False
    return True

for i in permutations('12345678'):
    if isprime(int(''.join(i))) : print(i)


<Problem42>

The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so the first ten triangle numbers are:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a triangle number then we shall call the word a triangle word.
Using words.txt (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?

Answer:

with open("p042_words.txt","r") as file:
    words= eval("["+ file.read() + "]")

char2int ={}
for x, y in list(enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ')): char2int[y] = x+1

tri_nums = [(i*(i+1))//2 for i in range(1,27)]

count= 0
for word in words :
    if sum(char2int[char] for char in word) in tri_nums : count += 1

print(count)


<Problem43>

The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, 
but it also has a rather interesting sub-string divisibility property.
Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:
d2d3d4=406 is divisible by 2
d3d4d5=063 is divisible by 3
d4d5d6=635 is divisible by 5
d5d6d7=357 is divisible by 7
d6d7d8=572 is divisible by 11
d7d8d9=728 is divisible by 13
d8d9d10=289 is divisible by 17
Find the sum of all 0 to 9 pandigital numbers with this property.

Answer:

from itertools import permutations

winners=[]
for i in permutations('0123456789'):
    pan =''.join(i)
    if int(pan[7:10])%17 == 0 and  int(pan[6:9])%13 == 0 and int(pan[5:8])%11 == 0 and \
        int(pan[4:7])%7 == 0 and int(pan[5])%5 == 0 and int(pan[2:5])%3 == 0 and int(pan[3])%2 == 0: 
        winners.append(int(pan))

print(sum(winners))

<Problem44>

Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?

Answer:

def PE044(c=1): # c : how many wants you ?
  i = D = 0
  while c:
    D+=3*i+1 ; i+=1 ; Pd = 0
    for d in range(1, i):
      Pd += 3*d-2
      j, r = divmod(D-Pd, 3*d)
      if (not r) and not (1+sqrt(1+24*(j*(3*j-1)+D)))%6:
        print(D)
        c-=1
PE044()


<Problem45>

Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
Triangle	 	 Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.
Find the next triangle number that is also pentagonal and hexagonal.

Answer:

from math import sqrt

def find(count):
    n, i = 1 ,1
    while count:
        n += 4*i+1; i+=1
        if (sqrt(1+8*n)-1)%2) and not (1+sqrt(1+24*n))%6 :
            print(n); count -=1

find(2)

<Problem46>

It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.
9 = 7 + 2×12
15 = 7 + 2×22
21 = 3 + 2×32
25 = 7 + 2×32
27 = 19 + 2×22
33 = 31 + 2×12
It turns out that the conjecture was false.
What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?

Answer:

n = 3
primes = set()

while True :
    if all( n % p for p in primes ) : primes.add( n )
    else :
        if not any( (n-2*i*i) in primes for i in xrange( 1, n ) ) : break
    n += 2
print n


<Problem47>

The first two consecutive numbers to have two distinct prime factors are:
14 = 2 × 7
15 = 3 × 5
The first three consecutive numbers to have three distinct prime factors are:
644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.
Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?

Answer1:

Limit=1000000
factors=[0]*Limit
for i in range(2,Limit):

    if factors[i]==0:
        count =0
        for ni in range(i,Limit,i): factors[ni] +=1

    elif factors[i] == 4:
        count +=1
        if count == 4:
            print (i-3) # First number
            break
        
    else:
        count = 0

Answer2:

max=1000000
n_factor = [0]*max

for i in range(2,max//2): 
    if n_factor[i] == 0 :
    	for j in range(2*i,max,i):
            n_factor[j] += 1

goal = [4]*4

for i in range(2,max):
     if n_factor[i:i+4] == goal:
        print (i)
        break

Answer3:

def PE47(lim=200000, dpf=4):
    L=[0]*(lim + 1)
    for i in xrange(2, lim/2+1):
        if L[i] == 0:
            for j in range(i, lim+1, i): 
                L[j]+=1
    return ''.join(map(str,L)).index(''.join(map(str, [dpf]*dpf)))

Answer4:

from itertools import count
sieve = {} # {(x = multiple of prime p) >= i: [p, known factor count in x]}
for i in count(2):          # count from 2 upwards
    if i not in sieve:      # if i is prime:
        want = 4            #   want 4 consecutive integers
        p = i
    else:
        p, factors = sieve.pop(i)  # have now noted all factors of i
        if factors < 4:     # non-prime i has less than 4 prime factors
            want = 4
        else:
            want -= 1
            if want == 0:
                return i-3
    # p divides i; find next unoccupied multiple of p in sieve
    while 1:
        i += p
        if i not in sieve: break
        sieve[i][1] += 1    # found one more factor (p) of i
    sieve[i] = [p, 1]       # so far, i has 1 known factor (p)


<Problem48>

The series, 11 + 22 + 33 + ... + 1010 = 10405071317.
Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.

Answer:

str(sum([i**i for i in range(1,1001)]))[-10:]


<Problem49>

The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: 
(i) each of the three terms are prime, and, 
(ii) each of the 4-digit numbers are permutations of one another.
There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.
What 12-digit number do you form by concatenating the three terms in this sequence?

Answer:

from itertools import combinations
from primestuff import primes

primelist=[x for x in primes(10000) if x>=1000]
per={}

for prime in primelist:
    digits = tuple(sorted(list(str(prime))))
    per.setdefault(digits,[]).append(prime)
                  
for key,primes in per.items():
    if len(primes)>=3:
        for p, q, r in combinations(primes,3):
            if (r-q)==(q-p): print (p,q,r)

What 12-digit number do you form by concatenating the three terms in this sequence?

<Problem50>

The prime 41, can be written as the sum of six consecutive primes:

41 = 2 + 3 + 5 + 7 + 11 + 13
This is the longest sum of consecutive primes that adds to a prime below one-hundred.

The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.

Which prime, below one-million, can be written as the sum of the most consecutive primes?

Answer1:

lim = 1000000
primes = primepy.upto(lim)
start, end, total, maxcount, maxprime = 0, 0, 0, 0, 0
while start<len(primes):
    while end<len(primes) and total+primes[end]<lim:
        total += primes[end]
        end += 1
    while (end-start>maxcount and not primepy.check(total)):
        end -= 1
        total -= primes[end]
    if end-start>maxcount:
        maxcount = end-start
        maxprime = total
    total -= primes[start]
    start += 1
print(maxcount, maxprime)

from primePy import primes as pp

def nextprime(n):
    x = n+1
    while True:
        if pp.check(x): return(x)
        else: x += 1       
        
primes = [0] + pp.upto(1000)
best = 21, 953
while True:    
    del primes[0]     
    s = sum(primes)
    while True:
        if s >= 10**6: break
        else:
            n = nextprime(primes[-1])
            s += n
            primes += [n]
    s = sum(primes[:best[0]+1])
    if s >= 10**6: break        
    for n in range(len(primes) - 1,best[0] + 1,-1):
        s = sum(primes[0:n])
        if pp.check(s):
            best = n,s
            break
print (best)